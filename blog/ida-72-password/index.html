<!doctype html><html lang=en><head><meta charset=utf-8><link href=https://seri.tools/style.css rel=stylesheet><title>How IDA 7.2's installer password was found</title><meta name=description><meta content="Dennis Duda" name=author><meta content="width=device-width,initial-scale=1" name=viewport><meta content=#292828 name=theme-color><link href=https://seri.tools/atom.xml rel=alternate title=RSS type=application/atom+xml><link href=https://seri.tools/rss.xml rel=alternate title=RSS type=application/rss+xml><body bgcolor=#333333 fgcolor=#ded9c9><div class=all><div class=header><header><div class="float-right top-nav"><a href=https://seri.tools/blog>Posts</a> | <a href=https://seri.tools/atom.xml>Atom</a> | <a href=https://seri.tools/rss.xml>RSS</a></div><h1 class=title><a href=https://seri.tools title=seri.tools><strong>seri</strong>.tools</a></h1></header></div><div><main><div class=content><p class=post-date>Posted: 2019-07-08<h1><a href=#>How IDA 7.2's installer password was found</a></h1><p><em>Note: All hashes and passwords are redacted.</em><h2 id=previously>Previously ... <a class=anchor href=#previously>#</a></h2><p>In January 2019, the installer files for IDA 7.2 were leaked. This does not mean it was usable however, as you need an installer password to install and a licence file to activate it. Separately to that, a license file from ESET was leaked, which didn't match the feature set of the installer file.<p>But all the leaks didn't matter, because without the installer password, the program files were safe. Until now. :)<p>On 2019-06-21, devcore published a <a href=https://devco.re/blog/2019/06/21/operation-crack-hacking-IDA-Pro-installer-PRNG-from-an-unusual-way-en/>blog post</a> about obvious flaws in the MacOS and Linux installers for IDA, including the password as plaintext in the setup file. The Windows installer, however, uses <a href=http://www.jrsoftware.org/isinfo.php>InnoSetup</a> as installation engine.<p>InnoSetup encrypts the program data with the installer password and hashes it via SHA-1, prepending it with <code>PasswordCheckHash</code> and eight random bytes as salt. The password being 12 alphanumeric characters long means that bruteforcing it is pretty much out of the question.<p>Unless you find out how the passwords were generated in the first place! Devcore found out that the passwords are simply generated with a small Perl script using <code>srand()</code>/<code>rand()</code>. This only works for versions up to 6.8 though, and not even all installers, as <em>qudiss</em> noted:<blockquote><p>I noticed <a href=https://rosettacode.org/wiki/Random_number_generator_(included)#Perl>Perl 5.20.0's PRNG implementation</a> can't be used to find seeds for the other leaked passwords or to bruteforce IDA 7.0-7.2 setup passwords. I assume different algorithms/charsets/etc. were used for these?<p>— <a href=https://devco.re/blog/2019/06/21/operation-crack-hacking-IDA-Pro-installer-PRNG-from-an-unusual-way-en/#comment-4511595557>qudiss</a></blockquote><p>I found that interesting and verified their findings by converting the code to Rust and do a full search for all PRNG seeds (assuming a 32-bit seed). To do that I've dug through the Perl source code to find the exact <a href=https://github.com/Perl/perl5/blob/df09255f565b73f060cd59e80498786e0f80d4a7/util.c#L5817>implementation of DRand48</a>. This, converted to Rust, amounts to something like:<pre class=language-rust data-lang=rust style=color:#e2cca9;background-color:#292828><code class=language-rust data-lang=rust><span style=color:#f2594b>use </span><span>float_extras::f64::ldexp;
</span><span>
</span><span style=color:#f2594b>pub struct </span><span style=color:#8bba7f>DRand48 </span><span>{
</span><span>    </span><span style=color:#f2594b>pub </span><span style=color:#fdf4c1>x</span><span>: </span><span style=color:#f2594b>u64
</span><span>}
</span><span>
</span><span style=color:#f2594b>impl </span><span style=color:#8bba7f>DRand48 </span><span>{
</span><span>    #[</span><span style=color:#fdf4c1>inline</span><span>]
</span><span>    </span><span style=color:#f2594b>pub fn </span><span style=color:#8bba7f>next_f64</span><span>(</span><span style=color:#f28534>&</span><span style=color:#f2594b>mut </span><span style=color:#fdf4c1>self</span><span>) -> </span><span style=color:#f2594b>f64 </span><span>{
</span><span>        </span><span style=color:#fdf4c1>self</span><span>.x </span><span style=color:#f28534>= </span><span style=color:#fdf4c1>self</span><span>.x
</span><span>            .</span><span style=color:#e9b143>wrapping_mul</span><span>(</span><span style=color:#d3869b>0x5DEE_CE66D</span><span>)
</span><span>            .</span><span style=color:#e9b143>wrapping_add</span><span>(</span><span style=color:#d3869b>0xB</span><span>)
</span><span>            </span><span style=color:#f28534>& </span><span style=color:#d3869b>0xFFFF_FFFF_FFFF</span><span>;
</span><span>        </span><span style=color:#e9b143>ldexp</span><span>(</span><span style=color:#fdf4c1>self</span><span>.x </span><span style=color:#f28534>as </span><span style=color:#f2594b>f64</span><span>, </span><span style=color:#f28534>-</span><span style=color:#d3869b>48</span><span>)
</span><span>    }
</span><span>
</span><span>    #[</span><span style=color:#fdf4c1>inline</span><span>]
</span><span>    </span><span style=color:#f2594b>pub fn </span><span style=color:#8bba7f>set_seed</span><span>(</span><span style=color:#f28534>&</span><span style=color:#f2594b>mut </span><span style=color:#fdf4c1>self</span><span>, </span><span style=color:#fdf4c1>seed</span><span>: </span><span style=color:#f2594b>u32</span><span>) {
</span><span>        </span><span style=color:#fdf4c1>self</span><span>.x </span><span style=color:#f28534>= </span><span style=color:#d3869b>0x330E</span><span style=color:#f2594b>u64 </span><span style=color:#f28534>+ </span><span>(</span><span style=color:#f2594b>u64</span><span>::from(seed) </span><span style=color:#f28534>&lt;&lt; </span><span style=color:#d3869b>16</span><span>);
</span><span>    }
</span><span>}
</span></code></pre><p>The rest is just a big loop over the full 32-bit range, setting the initial seed, generating the password, hashing it according to InnoSetup's scheme, and comparing that with the saved hash in the installer. Using <a href=https://github.com/rayon-rs/rayon>Rayon</a> I've quickly converted it to use multiple threads, yielding an >8x speed improvement on my system.<p>... and yes, as qudiss said, neither the IDA 7.0 nor the other mentioned leaked passwords can be found. So, what now?<h2 id=breaking-open-the-7-0-installer>Breaking open the 7.0 installer <a class=anchor href=#breaking-open-the-7-0-installer>#</a></h2><p>I guess I was pretty lucky since my first idea was actually correct. Qudiss' comment above included a very helpful link and hint: The PRNG implementation used in Perl was first introduced in Perl 5.20. So I've looked into what Perl used before DRand48 was added, thinking the passwords could have just be generated with an even older version.<p>And <a href=https://github.com/Perl/perl5/blob/05ccd577e15cc66bbb7414fad5ee3c02f536c7a5/uconfig.h#L3096>here</a> it is:<pre class=language-c data-lang=c style=color:#e2cca9;background-color:#292828><code class=language-c data-lang=c><span style=color:#f2594b>#define </span><span style=color:#8bba7f>Drand01</span><span>()       ((</span><span style=color:#e9b143>rand</span><span style=color:#fdf4c1>() </span><span style=color:#f28534>& </span><span style=color:#d3869b>0x7FFF</span><span>) </span><span style=color:#f28534>/ </span><span>(</span><span style=color:#f2594b>double</span><span>) ((</span><span style=color:#f2594b>unsigned long</span><span>)</span><span style=color:#d3869b>1 </span><span style=color:#f28534>&lt;&lt; </span><span style=color:#d3869b>15</span><span>))     </span><span style=color:#928374;font-style:italic>/**/
</span><span style=color:#f2594b>#define </span><span style=color:#8bba7f>Rand_seed_t     </span><span style=color:#f2594b>int    </span><span style=color:#928374;font-style:italic>/**/
</span><span style=color:#f2594b>#define </span><span style=color:#8bba7f>seedDrand01</span><span>(</span><span style=color:#fdf4c1>x</span><span>)  </span><span style=color:#e9b143>srand</span><span style=color:#fdf4c1>((Rand_seed_t)x)   </span><span style=color:#928374;font-style:italic>/**/
</span></code></pre><p>Just a simple call to the C functions <code>srand</code> and <code>rand</code>, converting the random number to a double with a bit of bit-fiddling.<p>Re-checking the full range was a little bit uglier with the older PRNG code, since C's <code>srand</code>/<code>rand</code> are not thread-safe, as it uses globals to store the PRNG state. This meant that instead of using rayon multithreading, the brute-force loop has to run single-threaded. To make the program not lose all of its previous speed, chunking the search space into 16 blocks and just running the tool 16 times in parallel worked well enough.<pre class=language-rs data-lang=rs style=color:#e2cca9;background-color:#292828><code class=language-rs data-lang=rs><span style=color:#f2594b>use </span><span>hex_literal::hex;
</span><span style=color:#f2594b>use </span><span>libc::{rand, srand};
</span><span style=color:#f2594b>use </span><span>sha1::{Digest, Sha1};
</span><span style=color:#f2594b>use </span><span>std::{env, </span><span style=color:#f2594b>f64</span><span>};
</span><span>
</span><span style=color:#f2594b>const </span><span style=color:#fdf4c1>CHARS</span><span>: </span><span style=color:#f28534>&</span><span>[</span><span style=color:#f2594b>u8</span><span>; </span><span style=color:#d3869b>54</span><span>] </span><span style=color:#f28534>= </span><span style=color:#f2594b>b</span><span style=color:#b0b846>"abcdefghijkmpqrstuvwxyzABCDEFGHJKLMPQRSTUVWXYZ23456789"</span><span>;
</span><span>
</span><span style=color:#f2594b>const </span><span style=color:#fdf4c1>HASH</span><span>: [</span><span style=color:#f2594b>u8</span><span>; </span><span style=color:#d3869b>20</span><span>] </span><span style=color:#f28534>= </span><span style=color:#e9b143>hex!</span><span>(</span><span style=color:#b0b846>"0000000000000000000000000000000000000000"</span><span>);
</span><span style=color:#f2594b>const </span><span style=color:#fdf4c1>PEPPER</span><span>: </span><span style=color:#f28534>&</span><span>[</span><span style=color:#f2594b>u8</span><span>; </span><span style=color:#d3869b>17</span><span>] </span><span style=color:#f28534>= </span><span style=color:#f2594b>b</span><span style=color:#b0b846>"PasswordCheckHash"</span><span>;
</span><span style=color:#f2594b>const </span><span style=color:#fdf4c1>SALT</span><span>: [</span><span style=color:#f2594b>u8</span><span>; </span><span style=color:#d3869b>8</span><span>] </span><span style=color:#f28534>= </span><span style=color:#e9b143>hex!</span><span>(</span><span style=color:#b0b846>"0000000000000000"</span><span>);
</span><span>
</span><span style=color:#f2594b>fn </span><span style=color:#8bba7f>main</span><span>() {
</span><span>    </span><span style=color:#f2594b>let</span><span> block_str </span><span style=color:#f28534>= </span><span>env::args().</span><span style=color:#e9b143>nth</span><span>(</span><span style=color:#d3869b>1</span><span>).</span><span style=color:#e9b143>expect</span><span>(</span><span style=color:#b0b846>"block"</span><span>);
</span><span>    </span><span style=color:#f2594b>let</span><span> block </span><span style=color:#f28534>=</span><span> block_str.parse::&lt;</span><span style=color:#f2594b>u32</span><span>>().</span><span style=color:#e9b143>expect</span><span>(</span><span style=color:#b0b846>"block"</span><span>);
</span><span>    </span><span style=color:#e9b143>assert!</span><span>(block </span><span style=color:#f28534>&lt; </span><span style=color:#d3869b>16</span><span>);
</span><span>
</span><span>    </span><span style=color:#f2594b>let</span><span> sha1template </span><span style=color:#f28534>= </span><span>{
</span><span>        </span><span style=color:#f2594b>let mut</span><span> hasher </span><span style=color:#f28534>= </span><span>Sha1::new();
</span><span>        hasher.</span><span style=color:#e9b143>input</span><span>(</span><span style=color:#fdf4c1>PEPPER</span><span>);
</span><span>        hasher.</span><span style=color:#e9b143>input</span><span>(</span><span style=color:#fdf4c1>SALT</span><span>);
</span><span>        hasher
</span><span>    };
</span><span>
</span><span>    </span><span style=color:#f2594b>let</span><span> start </span><span style=color:#f28534>=</span><span> block </span><span style=color:#f28534>&lt;&lt; </span><span style=color:#d3869b>28</span><span>;
</span><span>    </span><span style=color:#f2594b>let</span><span> length </span><span style=color:#f28534>= </span><span style=color:#d3869b>0x0FFF_FFFF</span><span style=color:#f2594b>u32</span><span>;
</span><span>
</span><span>    </span><span style=color:#f2594b>let mut</span><span> buf </span><span style=color:#f28534>= </span><span>[</span><span style=color:#d3869b>0</span><span style=color:#f2594b>u8</span><span>; </span><span style=color:#d3869b>12</span><span>];
</span><span>
</span><span>    </span><span style=color:#f2594b>for</span><span> i </span><span style=color:#f28534>in</span><span> start</span><span style=color:#f28534>..=</span><span>(start </span><span style=color:#f28534>+</span><span> length) {
</span><span>        </span><span style=color:#e9b143>perl_srand</span><span>(i);
</span><span>
</span><span>        </span><span style=color:#f2594b>for</span><span> n </span><span style=color:#f28534>in &</span><span style=color:#f2594b>mut</span><span> buf {
</span><span>            </span><span style=color:#f28534>*</span><span>n </span><span style=color:#f28534>= </span><span style=color:#fdf4c1>CHARS</span><span>[</span><span style=color:#e9b143>perl_rand</span><span>(</span><span style=color:#d3869b>54</span><span>) </span><span style=color:#f28534>as </span><span style=color:#f2594b>usize</span><span>];
</span><span>        }
</span><span>
</span><span>        </span><span style=color:#f2594b>let mut</span><span> hasher </span><span style=color:#f28534>=</span><span> sha1template.</span><span style=color:#e9b143>clone</span><span>();
</span><span>        hasher.</span><span style=color:#e9b143>input</span><span>(</span><span style=color:#f28534>&</span><span>buf);
</span><span>
</span><span>        </span><span style=color:#f2594b>let</span><span> hash </span><span style=color:#f28534>=</span><span> hasher.</span><span style=color:#e9b143>result</span><span>();
</span><span>
</span><span>        </span><span style=color:#f2594b>if</span><span> hash[</span><span style=color:#f28534>..</span><span>] </span><span style=color:#f28534>== </span><span style=color:#fdf4c1>HASH </span><span>{
</span><span>            </span><span style=color:#e9b143>println!</span><span>(</span><span style=color:#b0b846>"FOUND: </span><span style=color:#fdf4c1>{}</span><span style=color:#b0b846>"</span><span>, i);
</span><span>            </span><span style=color:#f2594b>return</span><span>;
</span><span>        }
</span><span>    }
</span><span>
</span><span>    </span><span style=color:#e9b143>println!</span><span>(</span><span style=color:#b0b846>"not found"</span><span>);
</span><span>}
</span><span>
</span><span>#[</span><span style=color:#fdf4c1>inline</span><span>]
</span><span style=color:#f2594b>fn </span><span style=color:#8bba7f>perl_srand</span><span>(</span><span style=color:#fdf4c1>seed</span><span>: </span><span style=color:#f2594b>u32</span><span>) {
</span><span>    </span><span style=color:#f2594b>unsafe </span><span>{ </span><span style=color:#e9b143>srand</span><span>(seed) }
</span><span>}
</span><span>
</span><span>#[</span><span style=color:#fdf4c1>inline</span><span>]
</span><span style=color:#f2594b>fn </span><span style=color:#8bba7f>perl_rand</span><span>(</span><span style=color:#fdf4c1>max</span><span>: </span><span style=color:#f2594b>u32</span><span>) -> </span><span style=color:#f2594b>u32 </span><span>{
</span><span>    (</span><span style=color:#f2594b>f64</span><span>::from(</span><span style=color:#f2594b>unsafe </span><span>{ </span><span style=color:#e9b143>rand</span><span>() } </span><span style=color:#f28534>& </span><span style=color:#d3869b>0x7FFF</span><span>) </span><span style=color:#f28534>/ </span><span>((</span><span style=color:#d3869b>1</span><span style=color:#f2594b>u64 </span><span style=color:#f28534>&lt;&lt; </span><span style=color:#d3869b>15</span><span>) </span><span style=color:#f28534>as </span><span style=color:#f2594b>f64</span><span>) </span><span style=color:#f28534>* </span><span style=color:#f2594b>f64</span><span>::from(max)) </span><span style=color:#f28534>as </span><span style=color:#f2594b>u32
</span><span>}
</span></code></pre><p>This, surprisingly, turned out to be the right idea and successfully bruteforced the other hashes/passwords (when using Microsoft's C runtime implementation for <code>srand</code> and <code>rand</code>).<h2 id=ida-7-2-though>IDA 7.2, though <a class=anchor href=#ida-7-2-though>#</a></h2><p>The next thing I've tested was the IDA 7.2 installer, of course. <a href=http://constexpr.org/innoextract/>InnoExtract</a> (<code>innoextract.exe --show-password</code>) is probably the easiest way of extracting the relevant data from the installer:<pre style=color:#e2cca9;background-color:#292828><code><span>Inspecting "IDA Pro v7.2 and Hex-Rays Decompiler (x64)" - setup data version 5.5.7 (unicode)
</span><span>Password hash: SHA-1 0000000000000000000000000000000000000000
</span><span>Password salt: 50617373776f7264436865636b486173680000000000000000 (hex bytes, prepended to password)
</span><span>Password encoding: UTF-16LE
</span><span>Done.
</span></code></pre><p>One thing that immediately stood out was the password encoding. IDA 7.2 uses the unicode variant of InnoSetup, hence the UTF16 encoding—previous installers used the ANSI variant. With a bit of unsafe slicing, the DRand48 version of the hashing code looks like this now:<pre class=language-rs data-lang=rs style=color:#e2cca9;background-color:#292828><code class=language-rs data-lang=rs><span style=color:#f2594b>let mut</span><span> buf </span><span style=color:#f28534>= </span><span>[</span><span style=color:#d3869b>0</span><span style=color:#f2594b>u16</span><span>; </span><span style=color:#d3869b>12</span><span>];
</span><span style=color:#f2594b>let mut</span><span> rand </span><span style=color:#f28534>=</span><span> DRand48 { x: </span><span style=color:#d3869b>0 </span><span>};
</span><span style=color:#f2594b>for</span><span> i </span><span style=color:#f28534>in</span><span> pos</span><span style=color:#f28534>..</span><span>(pos </span><span style=color:#f28534>+ </span><span style=color:#d3869b>0xFF_FFFF</span><span>) {
</span><span>    rand.</span><span style=color:#e9b143>set_seed</span><span>(i);
</span><span>
</span><span>    </span><span style=color:#f2594b>let mut</span><span> n </span><span style=color:#f28534>= </span><span style=color:#d3869b>0</span><span>;
</span><span>    </span><span style=color:#f2594b>while</span><span> n </span><span style=color:#f28534>&lt; </span><span style=color:#d3869b>12 </span><span>{
</span><span>        n </span><span style=color:#f28534>+= </span><span>(</span><span style=color:#fdf4c1>CHARS</span><span>[(rand.</span><span style=color:#e9b143>next_f64</span><span>() </span><span style=color:#f28534>* </span><span style=color:#d3869b>54.0</span><span>) </span><span style=color:#f28534>as </span><span style=color:#f2594b>usize</span><span>] </span><span style=color:#f28534>as </span><span style=color:#f2594b>char</span><span>)
</span><span>            .</span><span style=color:#e9b143>encode_utf16</span><span>(</span><span style=color:#f28534>&</span><span style=color:#f2594b>mut</span><span> buf[n</span><span style=color:#f28534>..</span><span>])
</span><span>            .</span><span style=color:#e9b143>len</span><span>();
</span><span>    }
</span><span>    </span><span style=color:#f2594b>let</span><span> hash </span><span style=color:#f28534>= </span><span>{
</span><span>        </span><span style=color:#f2594b>let mut</span><span> hasher </span><span style=color:#f28534>=</span><span> sha1template.</span><span style=color:#e9b143>clone</span><span>();
</span><span>        hasher.</span><span style=color:#e9b143>input</span><span>(</span><span style=color:#f2594b>unsafe </span><span>{
</span><span>            std::slice::from_raw_parts(
</span><span>                (buf[</span><span style=color:#f28534>..</span><span>]).</span><span style=color:#e9b143>as_ptr</span><span>() </span><span style=color:#f28534>as </span><span style=color:#f2594b>*const </span><span style=color:#f28534>_</span><span>,
</span><span>                buf[</span><span style=color:#f28534>..</span><span>].</span><span style=color:#e9b143>len</span><span>() </span><span style=color:#f28534>* </span><span style=color:#d3869b>2</span><span>,
</span><span>            )
</span><span>        });
</span><span>        hasher.</span><span style=color:#e9b143>result</span><span>()
</span><span>    };
</span><span>    </span><span style=color:#f2594b>if</span><span> hash[</span><span style=color:#f28534>..</span><span>] </span><span style=color:#f28534>== </span><span style=color:#fdf4c1>HASH </span><span>{
</span><span>        </span><span style=color:#f2594b>return </span><span style=color:#e9b143>Some</span><span>(buf);
</span><span>    }
</span><span>}
</span></code></pre><p>I've tried both the DRand48 PRNG and the older C-based PRNG, to no avail. Giving up for the night I've shared my findings as a reply to qudiss' comment.<p>On the next morning a lot of comments on both devco.re and the chinese discussion board pediy.com had appeared, pointing to a few more ideas to test. The first one was pretty simple, checking if the password length was increased to 14 characters, which sadly was not the case.<p>The second hint was posted as a small inconspicuous reply in the comments section on the devco.re blog post, by hishe:<blockquote><p>i think you need to omit the first rand.<p>this article doesn't mention this.<p>— <a href=https://devco.re/blog/2019/06/21/operation-crack-hacking-IDA-Pro-installer-PRNG-from-an-unusual-way-en/#comment-4512664132>hishe</a></blockquote><p>o_O<blockquote><p>Yup, got it!<p>— <a href=https://devco.re/blog/2019/06/21/operation-crack-hacking-IDA-Pro-installer-PRNG-from-an-unusual-way-en/#comment-4512903087>me in reply to hishe</a></blockquote><p>It probably was a well-educated guess by hishe that led to IDA 7.2 being finally pried open. Discarding the first generated number after setting the seed was everything that had to be changed to make it work (with DRand48):<pre class=language-rs data-lang=rs style=color:#e2cca9;background-color:#292828><code class=language-rs data-lang=rs><span style=color:#f2594b>for</span><span> i </span><span style=color:#f28534>in</span><span> pos</span><span style=color:#f28534>..</span><span>(pos </span><span style=color:#f28534>+ </span><span style=color:#d3869b>0xFF_FFFF</span><span>) {
</span><span>    rand.</span><span style=color:#e9b143>set_seed</span><span>(i);
</span><span>    </span><span style=color:#928374;font-style:italic>// skip first value
</span><span>    rand.</span><span style=color:#e9b143>next_f64</span><span>();
</span><span>
</span><span>    </span><span style=color:#928374;font-style:italic>// ... (see above)
</span></code></pre><p>After waiting for somebody else to post the actual password for the installer I pushed my code for anyone interested to see: <a href=https://github.com/seritools/find_drand48_innosetup_pw>gh/find_drand48_innosetup_pw</a><p>The timing of it all was lucky as well—the weakness was reported to Hex-Rays on January 31st 2019, while the leaks happened just a few weeks earlier. Since Hex-Rays promised to harden the installer password, this will probably be the last version of IDA to be leaked/cracked in a usable state without a password.</div></main></div><div class=footer><hr><footer>Dennis Duda | <a href=https://github.com/seritools>github/seritools</a><br><a href=https://hachyderm.io/@seri rel=me>hachyderm.io/@seri</a> | <a href=https://bsky.app/profile/seritools.bsky.social>@seritools.bsky.social</a> | <a href=https://x.com/seritools>x/@seritools</a><br> Discord: @seritools | <a href=https://www.linkedin.com/in/seritools/>LinkedIn</a><br><a href=/legal>Legal</a></footer></div></div>